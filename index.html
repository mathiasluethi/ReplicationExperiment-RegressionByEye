<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Slider Example</title>

  <link rel="stylesheet" href="styles.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

</head>
<body>
  <select onchange="selectParticipant()" id="participantDropdown">
    <option value="">choose participant</option>
    <option value="P1">P1</option>
    <option value="P2">P2</option>
    <option value="P3">P3</option>
    <option value="P4">P4</option>
    <option value="P5">P5</option>
    <option value="P6">P6</option>
    <option value="P7">P7</option>
    <option value="P8">P8</option>
    <option value="P9">P9</option>
    <option value="P10">P10</option>
    <option value="P11">P11</option>
    <option value="P12">P12</option>
    <option value="P13">P13</option>
    <option value="P14">P14</option>
    <option value="P15">P15</option>
    <option value="P16">P16</option>
  </select>

  <canvas id="myCanvas" width="300" height="525"></canvas>

  <div class="history">
    <span>m = </span>
    <span id="demo"></span>
  </div>

  <div class="slidecontainer">
    <input type="range" min="-1" max="1" step="0.01" value="0" class="slider" id="myRange">
  </div>

  <div class="buttonContainer">
    <button type="button" onclick="previous()">Previous</button>
    <button type="button" onclick="next()">Next</button>
  </div>

  <script type="text/javascript">
  let slider = document.getElementById("myRange");
  let output = document.getElementById("demo");
  let canvas = document.getElementById("myCanvas");
  ctxb = canvas.getContext("2d");
  output.innerHTML = slider.value;
  let data;
  let taskIndex = 0;
  let task;
  let background;
  let line;
  let participant = '';
  let graphtype;
  let taskCount;
  let headers;
  function selectParticipant() {
    participant = participantDropdown.value;
    console.log('pa: ', participant);
    setupExperiment();
  }

  // Setup experiment
  async function setupExperiment() {
    let d = loadData();
    data = await d;
    newGraph();
  }

  // Draws a new graph with background image, resets the slider
  function newGraph() {
    console.log(task);
    task = data[taskIndex];
    line = task.graphtype;
    slider.value = 0;
    output.innerHTML = 0;
    loadImage(task);
  }

  // Load in the csv file and convert it to an object
  async function loadData() {
    let data = $.get("./data/csvs/" + participant + ".csv").then(function(csv){
      var lines = csv.split("\n");
      var result = [];
      taskCount = lines.length - 1;
      console.log(taskCount);
      headers = lines[0].split(",");
      for(var i=1; i<lines.length; i++){
        var obj = {};
        var currentline = lines[i].split(",");
        for(var j=0; j<headers.length; j++){
          obj[headers[j]] = currentline[j];
        }
        result.push(obj);
      }
      return result;
    });
    return await data;
  }

  // Save experiment data to csv
  function saveData() {
    var array = typeof data != 'object' ? JSON.parse(data) : data;
    var str = headers;
    for (var i = 0; i < array.length; i++) {
      var line = '';
      for (var index in array[i]) {
        if (line != '') line += ','
        line += array[i][index];
      }
      str += line + '\r\n';
    }
    var hiddenElement = document.createElement('a');
    hiddenElement.href = 'data:text/csv;charset=utf-8,' + encodeURI(str);
    hiddenElement.target = '_blank';
    hiddenElement.download = participant + '.csv';
    hiddenElement.click();
    return str;
  }

  // Load images
  function loadImage(task) {
    background = new Image();
    background.src = task.src;
    // Make sure the image is loaded first otherwise nothing will draw.
    background.onload = function(){
      ctxb.drawImage(background,0,0,300,525);
    }
  }

  // Update the current slider value (each time you drag the slider handle)
  slider.oninput = function() {
    sliderValue = this.value;
    output.innerHTML = sliderValue;
    graphtype = line;
    drawRegression(sliderValue);
  }

  // Change the data based on input and move to the new task
  function next() {
    data[taskIndex].answer = slider.value;

    // fix to onchange/onclick
    /*
    if (slider.value == 0) {
      alert("Please change the slope before submitting your answer.");
    } else
    */

    if (taskIndex >= taskCount-1) {
      let csvData = saveData();
    } else {
      taskIndex = taskIndex + 1;
      newGraph();
    }
  }

  // Change the data based on input and move to the new task
  function previous() {
    if (taskIndex >= 1) {
      data[taskIndex].answer = slider.value;
      taskIndex = taskIndex - 1;
      newGraph();
    } else {
      alert("You can't move back. This is the first task.")
    }
  }

  //draw the regression
  function drawRegression(sliderValue) {
    let ctx = canvas.getContext("2d");
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'black';
    ctx.clearRect(0, 0, 300, 525);
    ctxb.drawImage(background, 0, 0, 300, 525);
    let resolution = 100;
    let X1, X2, Y1, Y2;
    ctx.beginPath();
    for (var i = 0; i < resolution; i++) {
      X1 = scale(i, 0, resolution, 0, 1);
      X2 = scale(i + 1, 0, resolution, 0, 1);
      if (graphtype === "line") {
        Y1 = 0.5 + (X1 - 0.5) * sliderValue;
        Y2 = 0.5 + (X2 - 0.5) * sliderValue;
      } else if (graphtype === "trig") {
        Y1 = 0.5 - 0.5 * Math.cos(X1 * Math.PI) * sliderValue;
        Y2 = 0.5 - 0.5 * Math.cos(X2 * Math.PI) * sliderValue;
      } else if (graphtype === "quad") {
        Y1 = 0.5 + sliderValue * Math.pow(X1,2) - 0.5 * sliderValue;
        Y2 = 0.5 + sliderValue * Math.pow(X2,2) - 0.5 * sliderValue;
      }
      ctx.moveTo(toScreenX(i/resolution),toScreenY(Y1));
      ctx.lineTo(toScreenX((i+1)/resolution),toScreenY(Y2));

    }
    ctx.stroke();
  }

  function toScreenY(dataY) {
    return scale(dataY, 0, 1, 525 - (2 * 5)- 112.5, (2 * 5) + 112.5);
  }
  function toScreenX(dataX) {
    return scale(dataX, 0, 1, (2*5), 300-(2*5));
  }
  const scale = (num, in_min, in_max, out_min, out_max) => {
    return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  }

  </script>

</body>
</html>
